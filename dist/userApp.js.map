{"version":3,"sources":["../dist-esnext/userApp.js"],"names":["user","password","Promise","resolve","passwordSalt","Error","passwordHash","undefined","hashPassword","V","tokenSecret","process","env","PASSWORD_SALT","getSalt","createApp","userAppArgs","userRepository","saveUser","findUsers","authUser","getAuthToken","verifyAuthToken","updatePassword","updatePasswordToken","deleteUser","seed","curry","args","userArgs","createdBy","authedUser","isValid","getOtherUsersWithSameUserNameOrEmail","otherUsers","getById","id","userDb","save","find","query","limit","options","form","getByUserNameOrEmail","userNameOrEmail","isPasswordCorrect","authToken","errors","push","ERROR_USERAPP_GETAUTHTOKEN_INVALID_USERNAME_OR_PASSWORD","token","repository","users","allUsers","ip","dtCreated","Date","displayName","email","userName","forEach"],"mappings":"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O,CAAC0B,UAAD,EAAgB;AAChC,QAAMC,QAAQ,qBAAYC,QAA1B;AACA,QAAMvB,aAAa;AACfwB,YAAI,EADW;AAEfC,mBAAW,IAAIC,IAAJ,EAFI;AAGfzD,cAAM;AACF0D,yBAAa,MADX;AAEFtB,gBAAI,6BAFF;AAGFuB,mBAAO,EAHL;AAIFC,sBAAU;AAJR;AAHS,KAAnB;AAUA,WAAOP,MAAMQ,OAAN;AAAA,8DAAc,kBAAO7D,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCAAsBkB,SAASkC,UAAT,EAAqB,EAAEvB,UAAU7B,IAAZ,EAAkB+B,sBAAlB,EAArB,CAAtB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAd;;AAAA;AAAA;AAAA;AAAA,QAAP;AACA;AACH,CAdM;AAeA,IAAMR,0CAAiB,SAAjBA,cAAiB,CAACK,IAAD,EAAU;AACpC,WAAO1B,QAAQC,OAAR,CAAgB,KAAhB,CAAP;AACH,CAFM;AAGA,IAAMqB,oDAAsB,SAAtBA,mBAAsB,CAACI,IAAD,EAAU;AACzC,WAAO1B,QAAQC,OAAR,CAAgB,KAAhB,CAAP;AACH,CAFM;AAGA,IAAMsB,kCAAa,SAAbA,UAAa,CAACG,IAAD,EAAU;AAChC,WAAO1B,QAAQC,OAAR,CAAgB,KAAhB,CAAP;AACH,CAFM;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"userApp.js","sourcesContent":["// import { BaseApp } from '@alanmarcell/ptz-core-app';\nimport { allErrors, authUserForm, \n// AuthUserForm,\ncreateUser, otherUsersWithSameUserNameOrEmail, updateUser, \n// User,\nusers as usersToSeed } from '@alanmarcell/ptz-user-domain';\nimport * as V from '@alanmarcell/ptz-validations';\nimport { compare, hash } from 'bcryptjs';\nimport { decode, encode } from 'jwt-simple';\nimport R from 'ramda';\n// TODO: Actions\n// static actions = {\n//     SAVE: 'USER_APP_SAVE',\n//     GET_AUTH_TOKEN: 'GET_AUTH_TOKEN'\n// };\nexport let tokenSecret = process.env.PASSWORD_SALT;\nexport let passwordSalt = process.env.PASSWORD_SALT;\nconst getSalt = () => {\n    tokenSecret = process.env.PASSWORD_SALT;\n    passwordSalt = process.env.PASSWORD_SALT;\n};\n// const userRepository: IUserRepository;\n// constructor(userAppArgs: IUserAppArgs) {\n//     super(userAppArgs);\n//     this.userRepository = userAppArgs.userRepository;\n// }\n// TODO: Actions\n// async execAction(action) {\n//     switch (action.type) {\n//         case UserApp.actions.SAVE:\n//             return await this.saveUser(action.args);\n//         case UserApp.actions.GET_AUTH_TOKEN:\n//             return await this.getAuthToken(action.args);\n//     }\n// }\nexport const createApp = (userAppArgs) => {\n    getSalt();\n    const userRepository = userAppArgs.userRepository;\n    return {\n        // userRepository: userAppArgs.userRepository,\n        // log: userAppArgs.log,\n        saveUser: saveUser(userRepository),\n        findUsers: findUsers(userRepository),\n        authUser: authUser(userRepository),\n        getAuthToken: getAuthToken(userRepository),\n        verifyAuthToken: verifyAuthToken(userRepository),\n        updatePassword,\n        updatePasswordToken,\n        deleteUser,\n        hashPassword,\n        seed\n    };\n};\n// export const passwordSalt = 'txt';\nexport async function hashPassword(user) {\n    if (!user.password)\n        return Promise.resolve(user);\n    if (!passwordSalt)\n        throw new Error('passwordSalt not added to process.env.');\n    user.passwordHash = await hash(user.password, passwordSalt);\n    user.password = undefined;\n    return Promise.resolve(user);\n}\nexport const saveUser = R.curry(async (userRepository, args) => {\n    args.userArgs.createdBy = args.authedUser;\n    var user = createUser(args.userArgs);\n    user = await hashPassword(user);\n    if (!V.isValid(user))\n        return Promise.resolve(user);\n    const otherUsers = await userRepository.getOtherUsersWithSameUserNameOrEmail(user);\n    user = otherUsersWithSameUserNameOrEmail(user, otherUsers);\n    if (!V.isValid(user))\n        return Promise.resolve(user);\n    const userDb = await userRepository.getById(user.id);\n    if (userDb)\n        user = updateUser(userDb, user);\n    user = await userRepository.save(user);\n    return Promise.resolve(user);\n});\nexport const findUsers = R.curry((userRepository, args) => {\n    return userRepository.find(args.query, { limit: args.options.limit });\n});\nexport const authUser = R.curry(async (userRepository, args) => {\n    const { form } = args;\n    const user = await userRepository.getByUserNameOrEmail(form.userNameOrEmail);\n    if (!user)\n        return Promise.resolve(null);\n    const isPasswordCorrect = await compare(form.password, user.passwordHash);\n    return Promise.resolve(isPasswordCorrect ? user : null);\n});\nexport const getAuthToken = R.curry(async (userRepository, args) => {\n    const form = authUserForm(args.form);\n    var authToken = null;\n    if (!V.isValid(form))\n        return Promise.resolve({\n            authToken,\n            user: null,\n            errors: form.errors\n        });\n    const user = await authUser(userRepository, args);\n    const errors = [];\n    if (user == null)\n        errors.push(allErrors.ERROR_USERAPP_GETAUTHTOKEN_INVALID_USERNAME_OR_PASSWORD);\n    else\n        authToken = encode(user, tokenSecret);\n    return Promise.resolve({\n        authToken,\n        user,\n        errors\n    });\n});\n// tslint:disable-next-line:max-line-length\nexport const verifyAuthToken = R.curry((userRepository, args) => {\n    const user = decode(args.token, passwordSalt);\n    return Promise.resolve(user);\n});\nexport const seed = (repository) => {\n    const users = usersToSeed.allUsers;\n    const authedUser = {\n        ip: '',\n        dtCreated: new Date(),\n        user: {\n            displayName: 'Seed',\n            id: 'ptz-user-app UserApp.seed()',\n            email: '',\n            userName: ''\n        }\n    };\n    return users.forEach(async (user) => await saveUser(repository, { userArgs: user, authedUser }));\n    // };\n};\nexport const updatePassword = (args) => {\n    return Promise.resolve(false);\n};\nexport const updatePasswordToken = (args) => {\n    return Promise.resolve(false);\n};\nexport const deleteUser = (args) => {\n    return Promise.resolve(false);\n};\n// export default class UserApp extends BaseApp implements IUserApp {\n//     // TODO: Actions\n//     // static actions = {\n//     //     SAVE: 'USER_APP_SAVE',\n//     //     GET_AUTH_TOKEN: 'GET_AUTH_TOKEN'\n//     // };\n//     tokenSecret = process.env.PASSWORD_SALT;\n//     passwordSalt = process.env.PASSWORD_SALT;\n//     private userRepository: IUserRepository;\n//     constructor(userAppArgs: IUserAppArgs) {\n//         super(userAppArgs);\n//         this.userRepository = userAppArgs.userRepository;\n//     }\n//     // TODO: Actions\n//     // async execAction(action) {\n//     //     switch (action.type) {\n//     //         case UserApp.actions.SAVE:\n//     //             return await this.saveUser(action.args);\n//     //         case UserApp.actions.GET_AUTH_TOKEN:\n//     //             return await this.getAuthToken(action.args);\n//     //     }\n//     // }\n//     async hashPassword(user: IUser): Promise<IUser> {\n//         if (!user.password)\n//             return Promise.resolve(user);\n//         if (!this.passwordSalt)\n//             throw new Error('passwordSalt not added to process.env.');\n//         user.passwordHash = await hash(user.password, this.passwordSalt);\n//         user.password = undefined;\n//         return Promise.resolve(user);\n//     }\n//     async saveUser(args: ISaveUserArgs): Promise<IUser> {\n//         args.userArgs.createdBy = args.authedUser;\n//         var user: IUser = new User(args.userArgs);\n//         user = await this.hashPassword(user);\n//         if (!user.isValid())\n//             return Promise.resolve(user);\n//         const otherUsers = await this.userRepository.getOtherUsersWithSameUserNameOrEmail(user);\n//         if (user.otherUsersWithSameUserNameOrEmail(otherUsers))\n//             return Promise.resolve(user);\n//         const userDb = await this.userRepository.getById(user.id);\n//         if (userDb)\n//             user = userDb.update(user);\n//         user = await this.userRepository.save(user);\n//         return Promise.resolve(user);\n//     }\n//     findUsers(args: IFindUsersArgs): Promise<IUser[]> {\n//         return this.userRepository.find(args.query, { limit: args.options.limit });\n//     }\n//     async authUser(args: IAuthUserArgs): Promise<IUser> {\n//         const { form } = args;\n//         const user = await this.userRepository.getByUserNameOrEmail(form.userNameOrEmail);\n//         if (!user)\n//             return Promise.resolve(null);\n//         const isPasswordCorrect = await compare(form.password, user.passwordHash);\n//         return Promise.resolve(isPasswordCorrect ? user : null);\n//     }\n//     async getAuthToken(args: IAuthUserArgs): Promise<IAuthToken> {\n//         const form = new AuthUserForm(args.form);\n//         var authToken = null;\n//         if (!form.isValid())\n//             return Promise.resolve({\n//                 authToken,\n//                 user: null,\n//                 errors: form.errors\n//             });\n//         const user = await this.authUser(args);\n//         const errors = [];\n//         if (user == null)\n//             errors.push(allErrors.ERROR_USERAPP_GETAUTHTOKEN_INVALID_USERNAME_OR_PASSWORD);\n//         else\n//             authToken = encode(user, this.tokenSecret);\n//         return Promise.resolve({\n//             authToken,\n//             user,\n//             errors\n//         });\n//     }\n//     verifyAuthToken(args: IVerifyAuthTokenArgs): Promise<User> {\n//         const user = decode(args.token, this.passwordSalt);\n//         return Promise.resolve(user);\n//     }\n//     async seed(users = usersToSeed.allUsers): Promise<void> {\n//         this.log('seeding users', users);\n//         const authedUser: ICreatedBy = {\n//             ip: '',\n//             dtCreated: new Date(),\n//             user: {\n//                 displayName: 'Seed',\n//                 id: 'ptz-user-app UserApp.seed()',\n//                 email: '',\n//                 userName: ''\n//             }\n//         };\n//         users.forEach(async user => await this.saveUser({ userArgs: user, authedUser }));\n//         return Promise.resolve();\n//     }\n//     async updatePassword(args: IUpdatePasswordArgs): Promise<boolean> {\n//         return Promise.resolve(false);\n//     }\n//     async updatePasswordToken(args: IUpdatePasswordTokenArgs): Promise<boolean> {\n//         return Promise.resolve(false);\n//     }\n//     async deleteUser(args: IDeleteUserArgs): Promise<boolean> {\n//         return Promise.resolve(false);\n//     }\n// }\n//# sourceMappingURL=userApp.js.map"]}